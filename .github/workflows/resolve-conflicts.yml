name: Resolve Merge Conflicts

# Runs after auto-rebase completes to resolve PRs that still have
# actual merge conflicts using the Claude API.
#
# Requires: ANTHROPIC_API_KEY secret in the repository.

on:
  # Run after auto-rebase finishes (proper sequencing, no sleep hack)
  workflow_run:
    workflows: ["Auto-Rebase PRs"]
    types: [completed]

  # Run when PRs are opened or updated — catches PRs that are created
  # with conflicts before the next push to main triggers Auto-Rebase.
  # The concurrency group ensures only one instance runs at a time.
  pull_request:
    types: [opened, synchronize]
    branches: [main]

  # Catch any stragglers (e.g. PRs made conflicting by force-pushes)
  schedule:
    - cron: "0 */2 * * *" # every 2 hours

  # Allow manual trigger
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

# Only one instance at a time to avoid race conditions
concurrency:
  group: resolve-conflicts
  cancel-in-progress: false

jobs:
  find-conflicted-prs:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.find.outputs.matrix }}
      has_conflicts: ${{ steps.find.outputs.has_conflicts }}
    steps:
      - name: Find PRs with merge conflicts
        id: find
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # GitHub lazily computes mergeable state — newly opened PRs may
          # show "UNKNOWN" for a few seconds. Retry up to 3 times with a
          # short delay so we don't miss freshly-conflicted PRs.
          for attempt in 1 2 3; do
            all_prs=$(gh pr list --repo "$GITHUB_REPOSITORY" --base main --state open \
              --json number,headRefName,mergeable)

            unknown_count=$(echo "$all_prs" | jq '[.[] | select(.mergeable == "UNKNOWN")] | length')

            if [ "$unknown_count" -eq 0 ] || [ "$attempt" -eq 3 ]; then
              break
            fi

            echo "Attempt $attempt: $unknown_count PR(s) have UNKNOWN mergeable state — waiting 10s for GitHub to compute..."
            sleep 10
          done

          prs=$(echo "$all_prs" | jq -c '[.[] | select(.mergeable == "CONFLICTING") | {number: .number, branch: .headRefName}]')

          echo "Conflicted PRs: $prs"

          if [ "$prs" = "[]" ] || [ -z "$prs" ]; then
            echo "has_conflicts=false" >> "$GITHUB_OUTPUT"
            echo "matrix={\"include\":[]}" >> "$GITHUB_OUTPUT"
          else
            echo "has_conflicts=true" >> "$GITHUB_OUTPUT"
            echo "matrix={\"include\":$prs}" >> "$GITHUB_OUTPUT"
          fi

  resolve:
    needs: find-conflicted-prs
    if: needs.find-conflicted-prs.outputs.has_conflicts == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 45
    strategy:
      matrix: ${{ fromJson(needs.find-conflicted-prs.outputs.matrix) }}
      max-parallel: 1 # Resolve one at a time to avoid push races
      fail-fast: false
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      # ── Fingerprint check: skip if we already tried this exact SHA combination ──
      - name: Check if already attempted
        id: fingerprint
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_BRANCH: ${{ matrix.branch }}
          PR_NUMBER: ${{ matrix.number }}
        run: |
          set -euo pipefail

          git fetch origin main
          git fetch origin "$PR_BRANCH"

          MAIN_SHA=$(git rev-parse origin/main)
          PR_SHA=$(git rev-parse "origin/$PR_BRANCH")
          FINGERPRINT="${PR_SHA:0:8}+${MAIN_SHA:0:8}"

          echo "fingerprint=$FINGERPRINT" >> "$GITHUB_OUTPUT"
          echo "Fingerprint: $FINGERPRINT (PR ${PR_SHA:0:8}, main ${MAIN_SHA:0:8})"

          # Check if there's already a failure comment with this exact fingerprint.
          # If so, skip — nothing has changed since the last attempt.
          EXISTING=$(gh api "repos/$GITHUB_REPOSITORY/issues/$PR_NUMBER/comments" \
            --jq "[.[] | select(.body | test(\"fingerprint: \`${FINGERPRINT}\`\"))] | length" 2>/dev/null || echo "0")

          if [ "$EXISTING" -gt 0 ]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "::notice::Skipping PR #$PR_NUMBER — already attempted for fingerprint $FINGERPRINT (same branch+main SHAs). Will retry when either branch is updated."
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Resolve conflicts (merge + commit, no push yet)
        if: steps.fingerprint.outputs.skip != 'true'
        id: resolve
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          PR_BRANCH: ${{ matrix.branch }}
          PR_NUMBER: ${{ matrix.number }}
        run: node .github/scripts/resolve-conflicts.mjs --no-push

      - uses: pnpm/action-setup@v4
        if: steps.fingerprint.outputs.skip != 'true'

      - name: Install dependencies
        if: steps.fingerprint.outputs.skip != 'true'
        run: pnpm install --frozen-lockfile

      - name: Validate resolved code
        if: steps.fingerprint.outputs.skip != 'true'
        id: validate
        run: |
          # Run the CI-blocking validation gate with --fix to auto-fix trivial
          # escaping/markdown issues that may arise from the merge, then validate.
          # This prevents the conflict resolver from pushing code that immediately
          # fails CI. Includes numeric ID integrity checks for duplicate detection.
          echo "Running post-resolution validation gate (with auto-fix)..."

          # Capture output for diagnostics while also streaming to logs.
          # The validate-gate now prints child process output for failed steps
          # even in CI mode, so we capture everything for the failure comment.
          GATE_OUTPUT=$(pnpm crux validate gate --fix 2>&1) && GATE_EXIT=0 || GATE_EXIT=$?

          # Always print to workflow logs
          echo "$GATE_OUTPUT"

          # Save last 80 lines for the PR failure comment
          GATE_TAIL=$(echo "$GATE_OUTPUT" | tail -80)
          {
            echo "gate_output<<GATEEOF"
            echo "$GATE_TAIL"
            echo "GATEEOF"
          } >> "$GITHUB_OUTPUT"

          if [ "$GATE_EXIT" -eq 0 ]; then
            echo "Validation passed — safe to push."
            echo "valid=true" >> "$GITHUB_OUTPUT"
          else
            echo "::error::Post-resolution validation failed — conflict resolution may have introduced errors."
            echo "valid=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi

      - name: Commit auto-fix changes (if any)
        if: steps.fingerprint.outputs.skip != 'true'
        run: |
          # The --fix flag may have auto-fixed escaping/markdown issues.
          # Create a separate commit (not amend) to preserve the merge commit's
          # integrity and make fixes visible in the PR history.
          if ! git diff --quiet || ! git diff --cached --quiet; then
            echo "Auto-fix produced changes — committing fixes..."
            git add -A
            git commit -m "Auto-fix escaping/markdown after conflict resolution"
          else
            echo "No auto-fix changes — merge commit is clean."
          fi

      - name: Push resolved merge
        if: steps.fingerprint.outputs.skip != 'true'
        env:
          PR_BRANCH: ${{ matrix.branch }}
        run: |
          # Push with retry for transient failures
          for attempt in 1 2 3; do
            if git push origin "$PR_BRANCH"; then
              echo "Pushed successfully."
              exit 0
            fi
            echo "Push attempt $attempt failed — retrying in $((attempt * 2))s..."
            sleep $((attempt * 2))
          done
          echo "::error::Push failed after 3 attempts"
          exit 1

      - name: Post success comment
        if: success() && steps.fingerprint.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr comment "${{ matrix.number }}" --repo "$GITHUB_REPOSITORY" \
            --body "Merge conflicts with \`main\` were automatically resolved by the conflict resolver. Please review the merge commit to ensure correctness."

      - name: Post failure comment
        if: failure() && steps.fingerprint.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # Pass through env var (not inline expression) to avoid bash treating
          # markdown backticks in the diagnostic summary as command substitution.
          DIAG: ${{ steps.resolve.outputs.diagnostic_summary }}
          GATE_OUTPUT: ${{ steps.validate.outputs.gate_output }}
          FINGERPRINT: ${{ steps.fingerprint.outputs.fingerprint }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          PR_NUMBER: ${{ matrix.number }}
        run: |
          # Build a detailed failure comment with diagnostics and fingerprint.
          # The fingerprint prevents re-attempting the same resolution when
          # nothing has changed (see "Check if already attempted" step).
          BODY="Automatic conflict resolution failed for this PR."
          BODY="$BODY Manual resolution is needed."

          if [ -n "$DIAG" ]; then
            BODY="$(printf '%s\n\n**Resolution diagnostics:**\n%s' "$BODY" "$DIAG")"
          fi

          if [ -n "$GATE_OUTPUT" ]; then
            BODY="$(printf '%s\n\n<details>\n<summary>Validation output (click to expand)</summary>\n\n```\n%s\n```\n\n</details>' "$BODY" "$GATE_OUTPUT")"
          fi

          BODY="$(printf '%s\n\n[View workflow logs](%s)\n\n<!-- fingerprint: `%s` -->' "$BODY" "$RUN_URL" "$FINGERPRINT")"

          gh pr comment "$PR_NUMBER" --repo "$GITHUB_REPOSITORY" --body "$BODY"
