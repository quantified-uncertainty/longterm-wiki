name: Resolve Merge Conflicts

# Runs after auto-rebase completes to resolve PRs that still have
# actual merge conflicts using the Claude API.
#
# Two-tier resolution:
#   1. Sonnet API — fast, cheap text-level conflict resolution (~$0.01-0.05/file)
#   2. Claude Code SDK — agentic escalation that can read errors and iterate
#
# Requires: ANTHROPIC_API_KEY secret in the repository.

on:
  # Run after auto-rebase finishes (proper sequencing, no sleep hack)
  workflow_run:
    workflows: ["Auto-Rebase PRs"]
    types: [completed]

  # Run when PRs are opened or updated — catches PRs that are created
  # with conflicts before the next push to main triggers Auto-Rebase.
  # The concurrency group ensures only one instance runs at a time.
  pull_request:
    types: [opened, synchronize]
    branches: [main]

  # Catch any stragglers (e.g. PRs made conflicting by force-pushes)
  schedule:
    - cron: "0 */2 * * *" # every 2 hours

  # Allow manual trigger
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

# Only one instance at a time to avoid race conditions
concurrency:
  group: resolve-conflicts
  cancel-in-progress: false

jobs:
  find-conflicted-prs:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.find.outputs.matrix }}
      has_conflicts: ${{ steps.find.outputs.has_conflicts }}
    steps:
      - name: Find PRs with merge conflicts
        id: find
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # GitHub lazily computes mergeable state — newly opened PRs may
          # show "UNKNOWN" for a few seconds. Retry up to 3 times with a
          # short delay so we don't miss freshly-conflicted PRs.
          for attempt in 1 2 3; do
            all_prs=$(gh pr list --repo "$GITHUB_REPOSITORY" --base main --state open \
              --json number,headRefName,mergeable)

            unknown_count=$(echo "$all_prs" | jq '[.[] | select(.mergeable == "UNKNOWN")] | length')

            if [ "$unknown_count" -eq 0 ] || [ "$attempt" -eq 3 ]; then
              break
            fi

            echo "Attempt $attempt: $unknown_count PR(s) have UNKNOWN mergeable state — waiting 10s for GitHub to compute..."
            sleep 10
          done

          prs=$(echo "$all_prs" | jq -c '[.[] | select(.mergeable == "CONFLICTING") | {number: .number, branch: .headRefName}]')

          echo "Conflicted PRs: $prs"

          if [ "$prs" = "[]" ] || [ -z "$prs" ]; then
            echo "has_conflicts=false" >> "$GITHUB_OUTPUT"
            echo "matrix={\"include\":[]}" >> "$GITHUB_OUTPUT"
          else
            echo "has_conflicts=true" >> "$GITHUB_OUTPUT"
            echo "matrix={\"include\":$prs}" >> "$GITHUB_OUTPUT"
          fi

  resolve:
    needs: find-conflicted-prs
    if: needs.find-conflicted-prs.outputs.has_conflicts == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 45
    strategy:
      matrix: ${{ fromJson(needs.find-conflicted-prs.outputs.matrix) }}
      max-parallel: 4 # Each job resolves a different PR branch — no push races
      fail-fast: false
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      # ── Fingerprint check: skip if we already tried this exact SHA combination ──
      - name: Check if already attempted
        id: fingerprint
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_BRANCH: ${{ matrix.branch }}
          PR_NUMBER: ${{ matrix.number }}
        run: |
          set -euo pipefail

          git fetch origin main
          git fetch origin "$PR_BRANCH"

          MAIN_SHA=$(git rev-parse origin/main)
          PR_SHA=$(git rev-parse "origin/$PR_BRANCH")
          FINGERPRINT="${PR_SHA:0:8}+${MAIN_SHA:0:8}"

          echo "fingerprint=$FINGERPRINT" >> "$GITHUB_OUTPUT"
          echo "Fingerprint: $FINGERPRINT (PR ${PR_SHA:0:8}, main ${MAIN_SHA:0:8})"

          # Check if there's already a failure comment with this exact fingerprint.
          # If so, skip — nothing has changed since the last attempt.
          EXISTING=$(gh api "repos/$GITHUB_REPOSITORY/issues/$PR_NUMBER/comments" \
            --jq "[.[] | select(.body | test(\"fingerprint: \`${FINGERPRINT}\`\"))] | length" 2>/dev/null || echo "0")

          if [ "$EXISTING" -gt 0 ]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "::notice::Skipping PR #$PR_NUMBER — already attempted for fingerprint $FINGERPRINT (same branch+main SHAs). Will retry when either branch is updated."
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      # ── Tier 1: Sonnet API — fast text-level conflict resolution ──
      - name: "Tier 1: Resolve conflicts with Sonnet (merge + commit, no push)"
        if: steps.fingerprint.outputs.skip != 'true'
        id: resolve
        continue-on-error: true # Don't fail the job — Tier 2 may fix it
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          PR_BRANCH: ${{ matrix.branch }}
          PR_NUMBER: ${{ matrix.number }}
        run: node .github/scripts/resolve-conflicts.mjs --no-push

      - uses: pnpm/action-setup@v4
        if: always() && steps.fingerprint.outputs.skip != 'true' && steps.resolve.outcome == 'success'

      - name: Install dependencies
        if: always() && steps.fingerprint.outputs.skip != 'true' && steps.resolve.outcome == 'success'
        run: pnpm install --frozen-lockfile

      - name: "Tier 1: Auto-fix escaping and markdown after merge"
        if: always() && steps.fingerprint.outputs.skip != 'true' && steps.resolve.outcome == 'success'
        run: |
          echo "Running auto-fix for MDX escaping and markdown formatting..."
          pnpm crux fix escaping || true
          pnpm crux fix markdown || true

      - name: "Tier 1: Validate resolved code"
        if: always() && steps.fingerprint.outputs.skip != 'true' && steps.resolve.outcome == 'success'
        id: validate
        continue-on-error: true # Don't fail the job — Tier 2 may fix it
        run: |
          echo "Running post-resolution validation gate (with auto-fix)..."

          GATE_OUTPUT=$(pnpm crux validate gate --fix 2>&1) && GATE_EXIT=0 || GATE_EXIT=$?

          # Always print to workflow logs (printf avoids echo misinterpreting leading -)
          printf '%s\n' "$GATE_OUTPUT"

          # Save last 80 lines for diagnostics
          GATE_TAIL=$(echo "$GATE_OUTPUT" | tail -80)
          {
            echo "gate_output<<GATEEOF"
            echo "$GATE_TAIL"
            echo "GATEEOF"
          } >> "$GITHUB_OUTPUT"

          if [ "$GATE_EXIT" -eq 0 ]; then
            echo "Tier 1 validation passed — safe to push."
          else
            echo "::warning::Tier 1 validation failed — will escalate to Tier 2 (Claude Code)."
            exit 1
          fi

      # ── Tier 2: Claude Code SDK — agentic escalation ──
      # Only runs if Tier 1 resolved conflicts (merge committed) but validation
      # failed. If the resolve script itself failed, the merge was aborted and
      # there's nothing for Tier 2 to fix — the failure comment handles that.
      - name: "Tier 2: Install Claude Code CLI"
        if: always() && steps.fingerprint.outputs.skip != 'true' && steps.validate.outcome == 'failure'
        run: npm install -g @anthropic-ai/claude-code@latest

      - name: "Tier 2: Agentic fix with Claude Code"
        if: always() && steps.fingerprint.outputs.skip != 'true' && steps.validate.outcome == 'failure'
        id: agentic
        timeout-minutes: 10
        continue-on-error: true
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GATE_OUTPUT: ${{ steps.validate.outputs.gate_output }}
        run: |
          echo "Escalating to Claude Code for agentic conflict resolution..."

          # Build prompt with validation error context
          PROMPT="$(cat <<PROMPT_EOF
          The automated conflict resolution system merged main into this PR branch and
          resolved all git conflict markers using Sonnet, but the post-merge validation
          failed. Your job is to fix the files so validation passes.

          Validation error output:
          $GATE_OUTPUT

          Instructions:
          1. Read the failing files to understand what went wrong
          2. Fix the issues — common causes after conflict resolution include:
             - YAML files with inconsistent ID formats (mixing slug IDs with hex-hash IDs)
             - TypeScript/JS files with type errors from combining incompatible changes
             - Build-data failures from mismatched entity/fact references between files
             - MDX files with broken EntityLink references
             - Numeric ID conflicts: if two entities/pages claim the same numericId, fix by
               giving one of them a unique ID. IDs are allocated by the wiki server.
             - Unescaped dollar signs in MDX files (e.g. "$100" should be "\\$100")
             - Deprecated frontmatter fields (e.g. "importance" should be "readerImportance")
          3. Run auto-fixers first: pnpm crux fix escaping && pnpm crux fix markdown
          4. After fixing, verify by running: pnpm crux validate gate --fix
          5. Only fix what's needed to pass validation — do not make unrelated changes
          6. Stage your changes with git add but do NOT commit or push
          PROMPT_EOF
          )"

          claude -p "$PROMPT" \
            --model sonnet \
            --dangerously-skip-permissions \
            --verbose

      - name: "Tier 2: Validate after agentic fix"
        if: always() && steps.fingerprint.outputs.skip != 'true' && steps.validate.outcome == 'failure' && steps.agentic.outcome == 'success'
        id: revalidate
        run: |
          echo "Running validation after Claude Code fix..."

          GATE_OUTPUT=$(pnpm crux validate gate --fix 2>&1) && GATE_EXIT=0 || GATE_EXIT=$?

          printf '%s\n' "$GATE_OUTPUT"

          GATE_TAIL=$(echo "$GATE_OUTPUT" | tail -80)
          {
            echo "gate_output<<GATEEOF"
            echo "$GATE_TAIL"
            echo "GATEEOF"
          } >> "$GITHUB_OUTPUT"

          if [ "$GATE_EXIT" -eq 0 ]; then
            echo "Tier 2 validation passed — safe to push."
          else
            echo "::error::Tier 2 validation also failed — manual resolution needed."
            exit 1
          fi

      # ── Commit, push, and comment (runs after whichever tier succeeded) ──
      - name: Commit auto-fix changes (if any)
        if: >-
          always() &&
          steps.fingerprint.outputs.skip != 'true' &&
          (steps.validate.outcome == 'success' || steps.revalidate.outcome == 'success')
        run: |
          if ! git diff --quiet || ! git diff --cached --quiet; then
            echo "Auto-fix produced changes — committing fixes..."
            git add -A
            TIER="${{ steps.validate.outcome == 'success' && 'Sonnet' || 'Claude Code' }}"
            git commit -m "Auto-fix after conflict resolution ($TIER)"
          else
            echo "No auto-fix changes — merge commit is clean."
          fi

      - name: Push resolved merge
        if: >-
          always() &&
          steps.fingerprint.outputs.skip != 'true' &&
          (steps.validate.outcome == 'success' || steps.revalidate.outcome == 'success')
        env:
          PR_BRANCH: ${{ matrix.branch }}
        run: |
          for attempt in 1 2 3; do
            if git push origin "$PR_BRANCH"; then
              echo "Pushed successfully."
              exit 0
            fi
            echo "Push attempt $attempt failed — retrying in $((attempt * 2))s..."
            sleep $((attempt * 2))
          done
          echo "::error::Push failed after 3 attempts"
          exit 1

      - name: Post success comment
        if: >-
          always() &&
          steps.fingerprint.outputs.skip != 'true' &&
          (steps.validate.outcome == 'success' || steps.revalidate.outcome == 'success')
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TIER: ${{ steps.validate.outcome == 'success' && 'Tier 1 (Sonnet)' || 'Tier 2 (Claude Code)' }}
        run: |
          gh pr comment "${{ matrix.number }}" --repo "$GITHUB_REPOSITORY" \
            --body "Merge conflicts with \`main\` were automatically resolved by the conflict resolver ($TIER). Please review the merge commit to ensure correctness."

      - name: Post failure comment
        if: >-
          always() &&
          steps.fingerprint.outputs.skip != 'true' &&
          (steps.resolve.outcome == 'failure' || steps.validate.outcome == 'failure') &&
          steps.revalidate.outcome != 'success'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DIAG: ${{ steps.resolve.outputs.diagnostic_summary }}
          RESOLVE_OUTCOME: ${{ steps.resolve.outcome }}
          GATE_OUTPUT_T1: ${{ steps.validate.outputs.gate_output }}
          GATE_OUTPUT_T2: ${{ steps.revalidate.outputs.gate_output }}
          FINGERPRINT: ${{ steps.fingerprint.outputs.fingerprint }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          PR_NUMBER: ${{ matrix.number }}
          AGENTIC_OUTCOME: ${{ steps.agentic.outcome }}
        run: |
          if [ "$RESOLVE_OUTCOME" = "failure" ]; then
            BODY="Automatic conflict resolution failed for this PR. The Sonnet conflict resolver could not merge the files."
          else
            BODY="Automatic conflict resolution failed for this PR (both Tier 1 Sonnet and Tier 2 Claude Code)."
          fi
          BODY="$BODY Manual resolution is needed."

          if [ -n "$DIAG" ]; then
            BODY="$(printf '%s\n\n**Resolution diagnostics:**\n%s' "$BODY" "$DIAG")"
          fi

          # Show Tier 1 validation output
          if [ -n "$GATE_OUTPUT_T1" ]; then
            BODY="$(printf '%s\n\n<details>\n<summary>Tier 1 (Sonnet) validation output</summary>\n\n```\n%s\n```\n\n</details>' "$BODY" "$GATE_OUTPUT_T1")"
          fi

          # Show Tier 2 info
          if [ "$AGENTIC_OUTCOME" = "success" ] && [ -n "$GATE_OUTPUT_T2" ]; then
            BODY="$(printf '%s\n\n<details>\n<summary>Tier 2 (Claude Code) validation output</summary>\n\n```\n%s\n```\n\n</details>' "$BODY" "$GATE_OUTPUT_T2")"
          elif [ "$AGENTIC_OUTCOME" = "failure" ]; then
            BODY="$(printf '%s\n\n**Tier 2 (Claude Code):** Agent failed to produce a fix.' "$BODY")"
          fi

          BODY="$(printf '%s\n\n[View workflow logs](%s)\n\n<!-- fingerprint: `%s` -->' "$BODY" "$RUN_URL" "$FINGERPRINT")"

          gh pr comment "$PR_NUMBER" --repo "$GITHUB_REPOSITORY" --body "$BODY"
