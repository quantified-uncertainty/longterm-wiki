/**
 * Adversarial Loop Phase
 *
 * Compound phase that closes the open-loop problem in the content pipeline:
 *
 *   improve → adversarial-review → [targeted-research → re-improve] × N → done
 *
 * The loop runs at most `maxAdversarialIterations` times (default 2).
 * Each iteration is targeted — only the specific gaps identified by the
 * adversarial reviewer are addressed, not a full re-research.
 *
 * Cost cap: re-research is skipped if no queries are emitted (edit-only gaps),
 * and early-exit stops the loop when no re-research gaps remain.
 */

import { MODELS } from '../../../lib/anthropic.ts';
import type {
  PageData, AnalysisResult, ResearchResult, PipelineOptions,
  AdversarialReviewResult, AdversarialLoopResult,
} from '../types.ts';
import { log, writeTemp } from '../utils.ts';
import { runAgent } from '../api.ts';
import { parseJsonFromLlm } from './json-parsing.ts';
import { adversarialReviewPhase } from './adversarial-review.ts';
import { improvePhase } from './improve.ts';

// ── Targeted research ─────────────────────────────────────────────────────────

/**
 * Run targeted web searches for the specific queries emitted by the adversarial reviewer.
 * Returns new sources to merge into the existing research.
 */
async function runTargetedResearch(
  page: PageData,
  queries: string[],
  options: PipelineOptions,
  iteration: number,
): Promise<ResearchResult> {
  log('adversarial-loop', `  Running targeted research (${queries.length} queries)`);

  if (queries.length === 0) {
    return { sources: [] };
  }

  const prompt = `You are a research assistant filling specific gaps in a wiki page about "${page.title}".

## Targeted Research Queries

These queries were generated by an adversarial reviewer who identified specific facts missing from the page. Search for each query and return the best sources.

${queries.map((q, i) => `${i + 1}. ${q}`).join('\n')}

## Instructions

For each query:
1. Run a web search with the query as-is
2. If it mentions EA Forum, LessWrong, or community discussion, also search SCRY

Extract from each source:
- Title, URL, author, date
- The specific facts that answer the query
- Relevance rating (high/medium/low)

Output ONLY a JSON object:
{
  "sources": [
    {
      "topic": "which query this addresses",
      "title": "source title",
      "url": "source URL",
      "author": "author if available",
      "date": "date if available",
      "facts": ["specific fact 1", "specific fact 2"],
      "relevance": "high"
    }
  ],
  "summary": "1-2 sentence summary of what was found"
}`;

  const tools = [
    {
      name: 'web_search',
      description: 'Search the web for information',
      input_schema: {
        type: 'object',
        properties: {
          query: { type: 'string', description: 'Search query' },
        },
        required: ['query'],
      },
    },
    {
      name: 'scry_search',
      description: 'Search EA Forum and LessWrong posts via SCRY',
      input_schema: {
        type: 'object',
        properties: {
          query: { type: 'string', description: 'Search query' },
          table: {
            type: 'string',
            enum: ['mv_eaforum_posts', 'mv_lesswrong_posts'],
            default: 'mv_eaforum_posts',
          },
        },
        required: ['query'],
      },
    },
  ];

  const result = await runAgent(prompt, {
    model: options.researchModel || MODELS.sonnet,
    maxTokens: 8000,
    tools,
  });

  const research = parseJsonFromLlm<ResearchResult>(result, 'adversarial-targeted-research', (raw, error) => ({
    sources: [],
    raw,
    error,
  }));

  log('adversarial-loop', `  Targeted research found ${research.sources?.length || 0} sources`);
  writeTemp(page.id, `adversarial-targeted-research-iter${iteration}.json`, research);
  return research;
}

/** Merge additional research sources into existing research. */
function mergeResearch(base: ResearchResult, additional: ResearchResult): ResearchResult {
  return {
    sources: [...(base.sources || []), ...(additional.sources || [])],
    summary: [base.summary, additional.summary].filter(Boolean).join(' '),
  };
}

/** Build directions string from adversarial review gaps for the re-improve call. */
function buildGapDirections(adversarialReview: AdversarialReviewResult): string {
  const editGaps = adversarialReview.gaps.filter(g => g.actionType === 'edit');
  const reSearchGaps = adversarialReview.gaps.filter(g => g.actionType === 're-research');

  const parts: string[] = [
    '## Adversarial Review Findings — Address These Gaps\n',
    `Overall: ${adversarialReview.overallAssessment}\n`,
  ];

  if (reSearchGaps.length > 0) {
    parts.push('### Gaps to Fill with New Research');
    reSearchGaps.forEach(g => parts.push(`- [${g.type}] ${g.description}`));
    parts.push('');
  }

  if (editGaps.length > 0) {
    parts.push('### Gaps to Fix by Editing');
    editGaps.forEach(g => parts.push(`- [${g.type}] ${g.description}`));
    parts.push('');
  }

  parts.push('Prioritize fixing these specific gaps. Do not rewrite sections that are already good.');

  return parts.join('\n');
}

// ── Main loop ─────────────────────────────────────────────────────────────────

export async function adversarialLoopPhase(
  page: PageData,
  initialContent: string,
  analysis: AnalysisResult,
  baseResearch: ResearchResult,
  directions: string,
  options: PipelineOptions,
): Promise<AdversarialLoopResult> {
  const maxIterations = options.maxAdversarialIterations ?? 2;
  log('adversarial-loop', `Starting adversarial loop (max ${maxIterations} iterations)`);

  let currentContent = initialContent;
  let cumulativeResearch = baseResearch;
  let lastAdversarialReview: AdversarialReviewResult = {
    gaps: [],
    needsReResearch: false,
    reResearchQueries: [],
    overallAssessment: 'Not yet run',
  };
  let iteration = 0;

  for (iteration = 1; iteration <= maxIterations; iteration++) {
    log('adversarial-loop', `\n--- Iteration ${iteration}/${maxIterations} ---`);

    // Step 1: Adversarial review of current content
    const adversarialReview = await adversarialReviewPhase(page, currentContent, options);
    lastAdversarialReview = adversarialReview;

    const totalGaps = adversarialReview.gaps.length;
    const actionableGaps = adversarialReview.gaps.filter(g => g.actionType !== 'none').length;

    if (totalGaps === 0 || actionableGaps === 0) {
      log('adversarial-loop', `Iteration ${iteration}: No actionable gaps found — stopping loop early`);
      break;
    }

    log('adversarial-loop', `Iteration ${iteration}: ${actionableGaps} actionable gaps (${adversarialReview.reResearchQueries.length} need re-research)`);

    // Step 2: Targeted re-research (only if re-research gaps exist)
    let iterationResearch: ResearchResult = { sources: [] };
    if (adversarialReview.needsReResearch && adversarialReview.reResearchQueries.length > 0) {
      iterationResearch = await runTargetedResearch(page, adversarialReview.reResearchQueries, options, iteration);
      cumulativeResearch = mergeResearch(cumulativeResearch, iterationResearch);
    } else {
      log('adversarial-loop', `Iteration ${iteration}: No re-research queries — will re-improve from edit instructions only`);
    }

    // Step 3: Re-improve with gap directions + merged research
    const gapDirections = buildGapDirections(adversarialReview);
    const combinedDirections = [directions, gapDirections].filter(Boolean).join('\n\n');

    log('adversarial-loop', `Iteration ${iteration}: Re-improving with ${cumulativeResearch.sources.length} total sources`);
    currentContent = await improvePhase(page, analysis, cumulativeResearch, combinedDirections, options);
    writeTemp(page.id, `adversarial-loop-iter${iteration}.mdx`, currentContent);
  }

  const result: AdversarialLoopResult = {
    iterations: iteration - 1,
    adversarialReview: lastAdversarialReview,
    additionalResearch: {
      sources: cumulativeResearch.sources.slice(baseResearch.sources.length),
    },
    finalContent: currentContent,
  };

  writeTemp(page.id, 'adversarial-loop-result.json', {
    iterations: result.iterations,
    gapsFound: lastAdversarialReview.gaps.length,
    sourcesAdded: result.additionalResearch.sources.length,
    overallAssessment: lastAdversarialReview.overallAssessment,
  });

  log('adversarial-loop', `\nAdversarial loop complete (${result.iterations} iteration(s), ${result.additionalResearch.sources.length} sources added)`);

  return result;
}
