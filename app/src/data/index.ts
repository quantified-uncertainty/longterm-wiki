/**
 * Data layer for longterm-wiki
 *
 * Reads database.json (generated by scripts/build-data.mjs) which contains
 * pre-transformed typedEntities. Runs at build time / server-component level only.
 *
 * Typed entities are validated via Zod schemas at load time.
 * See entity-schemas.ts for the schema definitions.
 */

import fs from "fs";
import path from "path";
import yaml from "js-yaml";
import {
  TypedEntitySchema,
  type TypedEntity,
  type GenericEntity,
  isRisk,
  isPerson,
  isOrganization,
  isPolicy,
} from "./entity-schemas";

// database.json is generated here by prebuild
const LOCAL_DATA_DIR = path.resolve(process.cwd(), "src/data");

// Source YAML data lives at the repo root
const DATA_DIR = path.resolve(process.cwd(), "../data");

// ============================================================================
// DATABASE LOADING
// ============================================================================

interface IdRegistryMaps {
  byNumericId: Record<string, string>; // E1 → slug
  bySlug: Record<string, string>; // slug → E1
}

export interface Fact {
  value?: string;
  numeric?: number;
  asOf?: string;
  source?: string;
  note?: string;
  noCompute?: boolean;
  compute?: string;
  format?: string;
  formatDivisor?: number;
  entity: string;
  factId: string;
  computed?: boolean;
}

/** Raw entity shape as stored in database.json (before transformation) */
interface RawEntity {
  id: string;
  type: string;
  title: string;
  description?: string;
  severity?: string;
  likelihood?: string | { level: string; status?: string; display?: string };
  timeframe?: string | { median: number; earliest?: number; latest?: number; display?: string };
  maturity?: string;
  website?: string;
  customFields?: { label: string; value: string; link?: string }[];
  relatedTopics?: string[];
  relatedEntries?: { id: string; type: string; relationship?: string }[];
  tags?: string[];
  lastUpdated?: string;
  sourceRefs?: string[];
  sources?: { title: string; url?: string; author?: string; date?: string }[];
  content?: unknown;
  numericId?: string;
  path?: string;
  status?: string;
  clusters?: string[];
  causeEffectGraph?: {
    title?: string;
    description?: string;
    nodes?: { id: string; [k: string]: unknown }[];
  };
}

interface DatabaseShape {
  typedEntities?: Array<Record<string, unknown>>;
  resources: Resource[];
  publications: Publication[];
  experts: Expert[];
  organizations: Organization[];
  backlinks: Record<string, BacklinkEntry[]>;
  pathRegistry: Record<string, string>;
  idRegistry: IdRegistryMaps;
  pages: Page[];
  facts: Record<string, Fact>;
  insights: DatabaseInsight[];
  stats: Record<string, unknown>;
}

// ============================================================================
// DATABASE LOADING
// ============================================================================

/** Union of fully-typed entities and generic (unknown-type) entities */
type AnyEntity = TypedEntity | GenericEntity;

let _database: DatabaseShape | null = null;
let _typedEntities: AnyEntity[] | null = null;

function getDatabase(): DatabaseShape {
  if (_database) return _database;

  const dbPath = path.join(LOCAL_DATA_DIR, "database.json");

  try {
    const raw = fs.readFileSync(dbPath, "utf-8");
    _database = JSON.parse(raw) as DatabaseShape;
  } catch (err) {
    throw new Error(
      `Failed to load database from ${dbPath}: ${err instanceof Error ? err.message : err}. ` +
      `Run "pnpm prebuild" first.`
    );
  }
  return _database;
}

function getTypedEntities(): AnyEntity[] {
  if (_typedEntities) return _typedEntities;

  const db = getDatabase();

  if (!db.typedEntities || db.typedEntities.length === 0) {
    throw new Error(
      'database.json is missing typedEntities. ' +
      'Run "pnpm --filter longterm-next prebuild" to rebuild.'
    );
  }

  const entities: AnyEntity[] = [];
  const isDev = process.env.NODE_ENV === "development";

  for (const raw of db.typedEntities) {
    const result = TypedEntitySchema.safeParse(raw);
    if (result.success) {
      entities.push(result.data);
    } else {
      // Unknown entity types (ai-transition-model-*, etc.) — keep all fields as-is.
      // Don't re-parse through GenericEntitySchema as Zod would strip extra keys
      // like content, currentAssessment, ratings, causeEffectGraph.
      if (isDev) {
        const id = (raw as Record<string, unknown>).id;
        const type = (raw as Record<string, unknown>).entityType;
        console.warn(
          `[entity-validation] ${id} (${type}): ${result.error.issues.map(i => i.message).join(", ")}`
        );
      }
      entities.push(raw as unknown as GenericEntity);
    }
  }

  _typedEntities = entities;
  return _typedEntities;
}

// ============================================================================
// TYPES (re-exported for consumers)
// ============================================================================

// Re-export typed entity types for consumers
export type { TypedEntity, GenericEntity, RiskEntity, PersonEntity, OrganizationEntity, PolicyEntity } from "./entity-schemas";
export type { AnyEntity };
export { isRisk, isPerson, isOrganization, isPolicy } from "./entity-schemas";

/** @deprecated Use TypedEntity instead */
export interface Entity {
  id: string;
  type: string;
  title: string;
  description?: string;
  severity?: string;
  likelihood?: any;
  timeframe?: any;
  maturity?: string;
  website?: string;
  customFields?: { label: string; value: string; link?: string }[];
  relatedTopics?: string[];
  relatedEntries?: { id: string; type: string; relationship?: string }[];
  tags?: string[];
  lastUpdated?: string;
  sourceRefs?: string[];
  sources?: { title: string; url?: string; author?: string; date?: string }[];
  content?: any;
}

export interface Resource {
  id: string;
  url: string;
  title: string;
  authors?: string[];
  published_date?: string;
  type: string;
  summary?: string;
  tags?: string[];
  publication_id?: string;
  credibility_override?: number;
}

export interface Publication {
  id: string;
  name: string;
  type: string;
  credibility: number;
  peer_reviewed?: boolean;
  domains: string[];
  description?: string;
}

export interface Expert {
  id: string;
  name: string;
  affiliation?: string;
  role?: string;
  website?: string;
  knownFor?: string[];
}

export interface Organization {
  id: string;
  name: string;
  type: string;
  founded?: string;
  headquarters?: string;
  website?: string;
  funding?: string;
  employees?: string;
}

export interface BacklinkEntry {
  id: string;
  type: string;
  title: string;
  relationship?: string;
}

export interface Page {
  id: string;
  path: string;
  filePath: string;
  title: string;
  quality: number | null;
  importance: number | null;
  tractability: number | null;
  neglectedness: number | null;
  uncertainty: number | null;
  causalLevel: string | null;
  lastUpdated: string | null;
  llmSummary: string | null;
  description: string | null;
  ratings: {
    novelty?: number;
    rigor?: number;
    actionability?: number;
    completeness?: number;
  } | null;
  category: string;
  subcategory?: string | null;
  tags?: string[];
  clusters?: string[];
  updateFrequency?: number | null;
  wordCount?: number;
  backlinkCount?: number;
  metrics?: {
    wordCount: number;
    tableCount: number;
    diagramCount: number;
    internalLinks: number;
    externalLinks: number;
    bulletRatio: number;
    sectionCount: number;
    hasOverview: boolean;
    structuralScore: number;
  };
  suggestedQuality?: number;
  unconvertedLinkCount?: number;
  redundancy?: {
    maxSimilarity: number;
    similarPages: Array<{
      id: string;
      title: string;
      path: string;
      similarity: number;
    }>;
  };
}

// ============================================================================
// LOOKUP INDEXES (built lazily)
// ============================================================================

let _typedEntityIndex: Map<string, AnyEntity> | null = null;
let _resourceIndex: Map<string, Resource> | null = null;
let _publicationIndex: Map<string, Publication> | null = null;
let _expertIndex: Map<string, Expert> | null = null;
let _orgIndex: Map<string, Organization> | null = null;
let _pageIndex: Map<string, Page> | null = null;

function typedEntityIndex() {
  if (!_typedEntityIndex) {
    _typedEntityIndex = new Map(getTypedEntities().map(e => [e.id, e]));
  }
  return _typedEntityIndex;
}

function resourceIndex() {
  if (!_resourceIndex) {
    const db = getDatabase();
    _resourceIndex = new Map((db.resources || []).map((r) => [r.id, r]));
  }
  return _resourceIndex;
}

function publicationIndex() {
  if (!_publicationIndex) {
    const db = getDatabase();
    _publicationIndex = new Map(
      (db.publications || []).map((p) => [p.id, p])
    );
  }
  return _publicationIndex;
}

function expertIndex() {
  if (!_expertIndex) {
    const db = getDatabase();
    _expertIndex = new Map((db.experts || []).map((e) => [e.id, e]));
  }
  return _expertIndex;
}

function orgIndex() {
  if (!_orgIndex) {
    const db = getDatabase();
    _orgIndex = new Map((db.organizations || []).map((o) => [o.id, o]));
  }
  return _orgIndex;
}

function pageIndex() {
  if (!_pageIndex) {
    const db = getDatabase();
    _pageIndex = new Map((db.pages || []).map((p) => [p.id, p]));
  }
  return _pageIndex;
}

// ============================================================================
// LOOKUP FUNCTIONS
// ============================================================================

/** Get a typed entity by ID (may be a generic entity for unknown types) */
export function getTypedEntityById(id: string): AnyEntity | undefined {
  return typedEntityIndex().get(id);
}

/** @deprecated Use getTypedEntityById for new code */
export function getEntityById(id: string): Entity | undefined {
  // Return typed entity cast to the old Entity interface for backward compat
  const typed = typedEntityIndex().get(id);
  if (!typed) return undefined;
  return {
    id: typed.id,
    type: typed.entityType,
    title: typed.title,
    description: typed.description,
    tags: typed.tags,
    relatedEntries: typed.relatedEntries,
    sources: typed.sources,
    lastUpdated: typed.lastUpdated,
    website: typed.website,
    customFields: typed.customFields,
    // Type-specific fields (spread them for backward compat)
    ...(isRisk(typed) ? {
      severity: typed.severity,
      likelihood: typed.likelihood,
      timeframe: typed.timeframe,
      maturity: typed.maturity,
    } : {}),
  };
}

export function getResourceById(id: string): Resource | undefined {
  return resourceIndex().get(id);
}

export function getPublicationById(id: string): Publication | undefined {
  return publicationIndex().get(id);
}

export function getExpertById(id: string): Expert | undefined {
  return expertIndex().get(id);
}

export function getOrganizationById(id: string): Organization | undefined {
  return orgIndex().get(id);
}

export function getPageById(id: string): Page | undefined {
  return pageIndex().get(id);
}

export function getAllPages(): Page[] {
  return getDatabase().pages || [];
}

export function getResourceCredibility(
  resource: Resource
): number | undefined {
  if (resource.credibility_override !== undefined) return resource.credibility_override;
  if (resource.publication_id) {
    const pub = getPublicationById(resource.publication_id);
    return pub?.credibility;
  }
  return undefined;
}

export function getResourcePublication(
  resource: Resource
): Publication | undefined {
  if (resource.publication_id) {
    return getPublicationById(resource.publication_id);
  }
  return undefined;
}

// ============================================================================
// PATH REGISTRY & ENTITY HREF
// ============================================================================

export function getEntityPath(id: string): string | null {
  const db = getDatabase();
  return db.pathRegistry?.[id] || db.pathRegistry?.[`__index__/${id}`] || null;
}

export function getIdRegistry(): IdRegistryMaps {
  return getDatabase().idRegistry;
}

export function getEntityHref(id: string, _type?: string): string {
  const registry = getIdRegistry();
  const numericId = registry.bySlug[id];
  return numericId ? `/wiki/${numericId}` : `/wiki/${id}`;
}

// ============================================================================
// BACKLINKS
// ============================================================================

export function getBacklinksFor(
  entityId: string
): Array<{
  id: string;
  type: string;
  title: string;
  href: string;
  relationship?: string;
}> {
  const db = getDatabase();
  const links = db.backlinks?.[entityId] || [];
  return links.map((link) => ({
    ...link,
    href: getEntityHref(link.id, link.type),
  }));
}

// ============================================================================
// CANONICAL FACTS
// ============================================================================

export function getFact(entityId: string, factId: string): Fact | undefined {
  const db = getDatabase();
  return db.facts?.[`${entityId}.${factId}`];
}

export function getFactValue(entityId: string, factId: string): string | undefined {
  return getFact(entityId, factId)?.value;
}

export function getFactsForEntity(entityId: string): Record<string, Fact> {
  const db = getDatabase();
  const result: Record<string, Fact> = {};
  for (const [key, fact] of Object.entries(db.facts || {})) {
    if (fact.entity === entityId) {
      result[fact.factId] = fact;
    }
  }
  return result;
}

export function getAllFacts(): Array<Fact & { key: string }> {
  const db = getDatabase();
  return Object.entries(db.facts || {}).map(([key, fact]) => ({
    ...fact,
    key,
  }));
}

// ============================================================================
// INFOBOX DATA HELPERS
// ============================================================================

export function getEntityInfoBoxData(entityId: string) {
  const entity = getTypedEntityById(entityId);
  if (!entity) return null;

  const resolvedRelatedEntries = entity.relatedEntries?.map((entry) => ({
    type: entry.type,
    title:
      getTypedEntityById(entry.id)?.title ||
      entry.id
        .split("-")
        .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
        .join(" "),
    href: getEntityHref(entry.id, entry.type),
  }));

  // Resolve likelihood/timeframe to strings
  let likelihoodStr: string | undefined;
  let timeframeStr: string | undefined;
  let category: string | undefined;
  let maturity: string | undefined;
  let relatedSolutions: any[] | undefined;
  let severity: string | undefined;

  if (isRisk(entity)) {
    severity = entity.severity;
    category = entity.riskCategory;
    maturity = entity.maturity;
    if (entity.likelihood) {
      likelihoodStr =
        typeof entity.likelihood === "string"
          ? entity.likelihood
          : entity.likelihood?.display || entity.likelihood?.level;
    }
    if (entity.timeframe) {
      timeframeStr =
        typeof entity.timeframe === "string"
          ? entity.timeframe
          : entity.timeframe?.display || String(entity.timeframe?.median || "");
    }
    // Find related solutions
    const allEntities = getTypedEntities();
    relatedSolutions = [];
    for (const solution of allEntities) {
      if (
        solution.entityType === "safety-agenda" ||
        solution.entityType === "approach" ||
        solution.entityType === "project"
      ) {
        const linkedRisks =
          solution.relatedEntries?.filter((re) => re.type === "risk") || [];
        if (linkedRisks.some((r) => r.id === entity.id)) {
          relatedSolutions.push({
            id: solution.id,
            title: solution.title,
            type: solution.entityType,
            href: getEntityHref(solution.id, solution.entityType),
          });
        }
      }
    }
  }

  // Person-specific fields
  let affiliation: string | undefined;
  let role: string | undefined;
  let knownFor: string | undefined;

  if (isPerson(entity)) {
    affiliation = entity.affiliation;
    role = entity.role;
    knownFor = entity.knownFor?.join(", ");
  }

  // Organization-specific fields
  let founded: string | undefined;
  let location: string | undefined;
  let headcount: string | undefined;
  let funding: string | undefined;
  let orgType: string | undefined;

  if (isOrganization(entity)) {
    founded = entity.founded;
    location = entity.headquarters;
    headcount = entity.employees;
    funding = entity.funding;
    orgType = entity.orgType;
  }

  // Policy-specific fields
  let introduced: string | undefined;
  let policyStatus: string | undefined;
  let policyAuthor: string | undefined;
  let scope: string | undefined;

  if (isPolicy(entity)) {
    introduced = entity.introduced;
    policyStatus = entity.policyStatus;
    policyAuthor = entity.author;
    scope = entity.scope;
  }

  return {
    type: entity.entityType,
    title: entity.title,
    severity,
    likelihood: likelihoodStr,
    timeframe: timeframeStr,
    website: entity.website,
    customFields: entity.customFields,
    relatedTopics: entity.relatedTopics,
    relatedEntries: resolvedRelatedEntries,
    category,
    maturity,
    relatedSolutions,
    // Person
    affiliation,
    role,
    knownFor,
    // Organization
    founded,
    location,
    headcount,
    funding,
    orgType,
    // Policy
    introduced,
    policyStatus,
    policyAuthor,
    scope,
  };
}

/** @deprecated Use getEntityInfoBoxData with entityId for person entities */
export function getExpertInfoBoxData(expertId: string) {
  return getEntityInfoBoxData(expertId);
}

/** @deprecated Use getEntityInfoBoxData with entityId for organization entities */
export function getOrgInfoBoxData(orgId: string) {
  return getEntityInfoBoxData(orgId);
}

// ============================================================================
// EXTERNAL LINKS (loads YAML via fs)
// ============================================================================

export interface ExternalLinksData {
  wikipedia?: string;
  wikidata?: string;
  lesswrong?: string;
  alignmentForum?: string;
  eaForum?: string;
  stampy?: string;
  arbital?: string;
  eightyK?: string;
}

let _externalLinksMap: Map<string, ExternalLinksData> | null = null;

function loadExternalLinksMap(): Map<string, ExternalLinksData> {
  if (_externalLinksMap) return _externalLinksMap;

  try {
    const yamlPath = path.join(DATA_DIR, "external-links.yaml");
    const raw = fs.readFileSync(yamlPath, "utf-8");
    const entries = yaml.load(raw) as Array<{
      pageId: string;
      links: ExternalLinksData;
    }>;
    _externalLinksMap = new Map();
    for (const entry of entries) {
      if (entry.pageId && entry.links) {
        _externalLinksMap.set(entry.pageId, entry.links);
      }
    }
    return _externalLinksMap;
  } catch {
    return new Map();
  }
}

export function getExternalLinks(
  pageId: string
): ExternalLinksData | undefined {
  return loadExternalLinksMap().get(pageId);
}

// ============================================================================
// EXPLORE PAGE DATA
// ============================================================================

export interface ExploreItem {
  id: string;
  numericId: string;
  title: string;
  type: string;
  description: string | null;
  tags: string[];
  clusters: string[];
  wordCount: number | null;
  quality: number | null;
  importance: number | null;
  category: string | null;
  riskCategory: string | null;
  lastUpdated: string | null;
  href?: string;
  meta?: string;
  sourceTitle?: string;
}

// Map page categories to entity-like types for display
const CATEGORY_TO_TYPE: Record<string, string> = {
  responses: "approach",
  organizations: "organization",
  people: "person",
  factors: "model",
  "intelligence-paradigms": "capability",
  models: "model",
  scenarios: "model",
  reports: "analysis",
  cruxes: "crux",
  worldviews: "concept",
  risks: "risk",
  forecasting: "model",
  "foundation-models": "capability",
  incidents: "historical",
  other: "concept",
};

// MANUAL MAINTENANCE: This table list is hardcoded because table metadata
// (row/col counts, descriptions) is not included in database.json.
// Update these values when tables change in the Astro app's ContentHub.
// TODO: Include table metadata in build-data.mjs output to automate this.
const TABLES = [
  {
    id: "transition-model",
    title: "AI Transition Model Parameters",
    description: "All AI Transition Model parameters.",
    href: "/wiki/table",
    path: "/ai-transition-model",
    rows: 45,
    cols: 6,
  },
];

// Insight shape as stored in database.json
interface DatabaseInsight {
  id: string;
  insight: string;
  source: string;
  tags: string[];
  type: string;
  surprising: number;
  important: number;
  actionable: number;
  neglected: number;
  compact: number;
  added: string;
  composite?: number | null;
}

export function getExploreItems(): ExploreItem[] {
  const db = getDatabase();
  const typedEntities = getTypedEntities();
  const pageMap = new Map((db.pages || []).map((p) => [p.id, p]));
  const entityIds = new Set(typedEntities.map((e) => e.id));

  // Build cluster lookup from pages (for tables/insights)
  const pageClusterMap = new Map<string, string[]>();
  const pageTitleMap = new Map<string, string>();
  for (const page of db.pages || []) {
    pageClusterMap.set(page.path, page.clusters || []);
    pageTitleMap.set(page.path, page.title);
    if (!page.path.endsWith("/")) {
      pageClusterMap.set(page.path + "/", page.clusters || []);
      pageTitleMap.set(page.path + "/", page.title);
    }
  }

  // Items from typed entities (only those with actual content pages)
  const entityItems: ExploreItem[] = typedEntities.filter((entity) => pageMap.has(entity.id)).map((entity) => {
    const page = pageMap.get(entity.id)!;
    return {
      id: entity.id,
      numericId: entity.numericId || db.idRegistry?.bySlug[entity.id] || entity.id,
      title: entity.title,
      type: entity.entityType,
      description: page?.llmSummary || page?.description || entity.description || null,
      tags: entity.tags || [],
      clusters: entity.clusters?.length ? entity.clusters : (page?.clusters || []),
      wordCount: page?.wordCount ?? null,
      quality: page?.quality ?? null,
      importance: page?.importance ?? null,
      category: page?.category ?? null,
      riskCategory: isRisk(entity) ? (entity.riskCategory || null) : null,
      lastUpdated: page?.lastUpdated ?? null,
    };
  });

  // Items from pages that have no entity
  const pageOnlyItems: ExploreItem[] = (db.pages || [])
    .filter((p) => !entityIds.has(p.id))
    .filter((p) => p.title && p.category !== "schema")
    .map((page) => ({
      id: page.id,
      numericId: db.idRegistry?.bySlug[page.id] || page.id,
      title: page.title,
      type: CATEGORY_TO_TYPE[page.category] || "concept",
      description: page.llmSummary || page.description || null,
      tags: page.tags || [],
      clusters: page.clusters || [],
      wordCount: page.wordCount ?? null,
      quality: page.quality ?? null,
      importance: page.importance ?? null,
      category: page.category ?? null,
      riskCategory: null,
      lastUpdated: page.lastUpdated ?? null,
    }));

  // Table items
  const tableItems: ExploreItem[] = TABLES.map((table) => ({
    id: `table-${table.id}`,
    numericId: `table-${table.id}`,
    title: table.title,
    type: "table",
    description: table.description,
    tags: [],
    clusters: pageClusterMap.get(table.path) || ["ai-safety"],
    wordCount: null,
    quality: null,
    importance: null,
    category: null,
    riskCategory: null,
    lastUpdated: null,
    href: table.href,
    meta: `${table.rows} × ${table.cols}`,
  }));

  // Diagram items — entities with causeEffectGraph data
  // Generic entities preserve all raw fields including causeEffectGraph
  const diagramItems: ExploreItem[] = typedEntities
    .filter((e) => {
      const ceg = (e as unknown as RawEntity).causeEffectGraph;
      return (ceg?.nodes?.length ?? 0) > 0;
    })
    .map((e) => {
      const ceg = (e as unknown as RawEntity).causeEffectGraph!;
      const nodeCount = ceg.nodes?.length || 0;
      return {
        id: `diagram-${e.id}`,
        numericId: `diagram-${e.id}`,
        title: ceg.title || e.title,
        type: "diagram",
        description: ceg.description || `Cause-effect diagram for ${e.title}`,
        tags: [],
        clusters: ["ai-safety"],
        wordCount: null,
        quality: null,
        importance: null,
        category: null,
        riskCategory: null,
        lastUpdated: e.lastUpdated || null,
        href: getEntityHref(e.id),
        meta: `${nodeCount} nodes`,
      };
    });

  // Insight items
  const insightItems: ExploreItem[] = (db.insights || []).map((insight) => {
    const sourcePath = insight.source || "/insight-hunting";
    const parentClusters =
      pageClusterMap.get(sourcePath) ||
      pageClusterMap.get(sourcePath + "/") ||
      ["ai-safety"];
    const sourceTitle =
      pageTitleMap.get(sourcePath) ||
      pageTitleMap.get(sourcePath + "/") ||
      undefined;
    return {
      id: `insight-${insight.id}`,
      numericId: `insight-${insight.id}`,
      title: insight.insight,
      type: "insight",
      description: insight.insight,
      tags: insight.tags || [],
      clusters: parentClusters,
      wordCount: null,
      quality: insight.composite || null,
      importance: insight.composite || null,
      category: null,
      riskCategory: null,
      lastUpdated: null,
      href: sourcePath,
      meta: insight.composite?.toFixed(1) || undefined,
      sourceTitle,
    };
  });

  return [...entityItems, ...pageOnlyItems, ...tableItems, ...diagramItems, ...insightItems];
}
