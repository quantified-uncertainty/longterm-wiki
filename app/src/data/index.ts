/**
 * Data layer for longterm-wiki
 *
 * Reads database.json (generated by scripts/build-data.mjs) which contains
 * pre-transformed typedEntities. Runs at build time / server-component level only.
 *
 * Typed entities are validated via Zod schemas at load time.
 * See entity-schemas.ts for the schema definitions.
 */

import fs from "fs";
import path from "path";
import yaml from "js-yaml";
import {
  TypedEntitySchema,
  type TypedEntity,
  type GenericEntity,
  isRisk,
  isPerson,
  isOrganization,
  isPolicy,
} from "./entity-schemas";

// database.json is generated here by prebuild
const LOCAL_DATA_DIR = path.resolve(process.cwd(), "src/data");

// Source YAML data lives at the repo root
const DATA_DIR = path.resolve(process.cwd(), "../data");

// ============================================================================
// DATABASE LOADING
// ============================================================================

interface IdRegistryMaps {
  byNumericId: Record<string, string>; // E1 → slug
  bySlug: Record<string, string>; // slug → E1
}

export interface Fact {
  value?: string;
  numeric?: number;
  /** Lower bound of range (for estimates like "$20-26 billion") */
  low?: number;
  /** Upper bound of range */
  high?: number;
  asOf?: string;
  source?: string;
  note?: string;
  noCompute?: boolean;
  /** Measure ID from data/fact-measures.yaml — groups related facts into timeseries.
   *  Auto-inferred from fact ID at build time if not set explicitly. */
  measure?: string;
  /** Subject override — defaults to parent entity. Use for benchmark/comparison facts
   *  (e.g., subject: "industry-average") that shouldn't appear in entity timeseries. */
  subject?: string;
  compute?: string;
  format?: string;
  formatDivisor?: number;
  entity: string;
  factId: string;
  computed?: boolean;
}

export interface FactMeasure {
  id: string;
  label: string;
  unit: string;
  category: string;
  direction?: "higher" | "lower";
  description?: string;
  display?: {
    divisor?: number;
    prefix?: string;
    suffix?: string;
  };
  relatedMeasures?: string[];
  applicableTo?: string[];
}

/** A timeseries entry — a fact observation for a specific entity+measure at a point in time */
export interface TimeseriesPoint {
  entity: string;
  factId: string;
  measure: string;
  asOf: string;
  value?: string;
  numeric?: number;
  low?: number;
  high?: number;
  note?: string;
  source?: string;
}

/** Raw entity shape as stored in database.json (before transformation) */
interface RawEntity {
  id: string;
  type: string;
  title: string;
  description?: string;
  severity?: string;
  likelihood?: string | { level: string; status?: string; display?: string };
  timeframe?: string | { median: number; earliest?: number; latest?: number; display?: string };
  maturity?: string;
  website?: string;
  customFields?: { label: string; value: string; link?: string }[];
  relatedTopics?: string[];
  relatedEntries?: { id: string; type: string; relationship?: string }[];
  tags?: string[];
  lastUpdated?: string;
  sourceRefs?: string[];
  sources?: { title: string; url?: string; author?: string; date?: string }[];
  content?: unknown;
  numericId?: string;
  path?: string;
  status?: string;
  clusters?: string[];
  causeEffectGraph?: {
    title?: string;
    description?: string;
    nodes?: { id: string; [k: string]: unknown }[];
  };
}

interface RelatedGraphEntry {
  id: string;
  type: string;
  title: string;
  score: number;
  label?: string;
}

export interface Intervention {
  id: string;
  name: string;
  category?: string;
  description?: string;
  riskCoverage?: {
    accident?: string;
    misuse?: string;
    structural?: string;
    epistemic?: string;
  };
  primaryMechanism?: string;
  tractability?: string;
  neglectedness?: string;
  importance?: string;
  overallPriority?: string;
  timelineFit?: string;
  currentState?: string;
  fundingLevel?: string;
  fundingShare?: string;
  recommendedShift?: string;
  wikiPageId?: string;
  relatedInterventions?: string[];
  relevantResearch?: Array<{ title: string; url?: string }>;
}

interface DatabaseShape {
  typedEntities?: Array<Record<string, unknown>>;
  resources: Resource[];
  publications: Publication[];
  experts: Expert[];
  organizations: Organization[];
  interventions: Intervention[];
  proposals: Proposal[];
  prItems: PrItem[];
  backlinks: Record<string, BacklinkEntry[]>;
  relatedGraph: Record<string, RelatedGraphEntry[]>;
  pathRegistry: Record<string, string>;
  idRegistry: IdRegistryMaps;
  pages: Page[];
  facts: Record<string, Fact>;
  factMeasures: Record<string, FactMeasure>;
  /** Timeseries index: measure ID → sorted array of observations */
  factTimeseries: Record<string, TimeseriesPoint[]>;
  stats: Record<string, unknown>;
}

// ============================================================================
// DATABASE LOADING
// ============================================================================

/** Union of fully-typed entities and generic (unknown-type) entities */
type AnyEntity = TypedEntity | GenericEntity;

let _database: DatabaseShape | null = null;
let _typedEntities: AnyEntity[] | null = null;

function getDatabase(): DatabaseShape {
  if (_database) return _database;

  const dbPath = path.join(LOCAL_DATA_DIR, "database.json");

  try {
    const raw = fs.readFileSync(dbPath, "utf-8");
    _database = JSON.parse(raw) as DatabaseShape;
  } catch (err) {
    throw new Error(
      `Failed to load database from ${dbPath}: ${err instanceof Error ? err.message : err}. ` +
      `Run "pnpm prebuild" first.`
    );
  }
  return _database;
}

function getTypedEntities(): AnyEntity[] {
  if (_typedEntities) return _typedEntities;

  const db = getDatabase();

  if (!db.typedEntities || db.typedEntities.length === 0) {
    throw new Error(
      'database.json is missing typedEntities. ' +
      'Run "pnpm --filter longterm-next prebuild" to rebuild.'
    );
  }

  const entities: AnyEntity[] = [];
  const isDev = process.env.NODE_ENV === "development";

  for (const raw of db.typedEntities) {
    const result = TypedEntitySchema.safeParse(raw);
    if (result.success) {
      entities.push(result.data);
    } else {
      // Unknown entity types (ai-transition-model-*, etc.) — keep all fields as-is.
      // Don't re-parse through GenericEntitySchema as Zod would strip extra keys
      // like content, currentAssessment, ratings, causeEffectGraph.
      if (isDev) {
        const id = (raw as Record<string, unknown>).id;
        const type = (raw as Record<string, unknown>).entityType;
        console.warn(
          `[entity-validation] ${id} (${type}): ${result.error.issues.map(i => i.message).join(", ")}`
        );
      }
      entities.push(raw as unknown as GenericEntity);
    }
  }

  _typedEntities = entities;
  return _typedEntities;
}

// ============================================================================
// TYPES (re-exported for consumers)
// ============================================================================

// Re-export typed entity types for consumers
export type { TypedEntity, GenericEntity, RiskEntity, PersonEntity, OrganizationEntity, PolicyEntity } from "./entity-schemas";
export type { AnyEntity };

/** @deprecated Use TypedEntity instead */
interface Entity {
  id: string;
  type: string;
  title: string;
  description?: string;
  severity?: string;
  likelihood?: string | { level: string; status?: string; display?: string };
  timeframe?: string | { median: number; earliest?: number; latest?: number; display?: string };
  maturity?: string;
  website?: string;
  customFields?: { label: string; value: string; link?: string }[];
  relatedTopics?: string[];
  relatedEntries?: { id: string; type: string; relationship?: string }[];
  tags?: string[];
  lastUpdated?: string;
  sourceRefs?: string[];
  sources?: { title: string; url?: string; author?: string; date?: string }[];
  content?: unknown;
}

interface Resource {
  id: string;
  url: string;
  title: string;
  authors?: string[];
  published_date?: string;
  type: string;
  summary?: string;
  tags?: string[];
  publication_id?: string;
  credibility_override?: number;
}

interface Publication {
  id: string;
  name: string;
  type: string;
  credibility: number;
  peer_reviewed?: boolean;
  domains: string[];
  description?: string;
}

interface Expert {
  id: string;
  name: string;
  affiliation?: string;
  role?: string;
  website?: string;
  knownFor?: string[];
}

interface Organization {
  id: string;
  name: string;
  type: string;
  founded?: string;
  headquarters?: string;
  website?: string;
  funding?: string;
  employees?: string;
}

interface BacklinkEntry {
  id: string;
  type: string;
  title: string;
  relationship?: string;
}

export type ContentFormat = 'article' | 'table' | 'diagram' | 'index' | 'dashboard';

export interface StructuredSummary {
  oneLiner: string;
  keyPoints: string[];
  bottomLine: string;
}

export interface ChangeEntry {
  date: string;
  branch: string;
  title: string;
  summary: string;
  pr?: number;
  model?: string;
  duration?: string;
  cost?: string;
}

export interface Page {
  id: string;
  path: string;
  filePath: string;
  title: string;
  quality: number | null;
  readerImportance: number | null;
  researchImportance: number | null;
  contentFormat: ContentFormat;
  tractability: number | null;
  neglectedness: number | null;
  uncertainty: number | null;
  causalLevel: string | null;
  lastUpdated: string | null;
  llmSummary: string | null;
  structuredSummary: StructuredSummary | null;
  description: string | null;
  ratings: {
    novelty?: number;
    rigor?: number;
    actionability?: number;
    completeness?: number;
  } | null;
  category: string;
  subcategory?: string | null;
  tags?: string[];
  clusters?: string[];
  updateFrequency?: number | null;
  evergreen?: boolean;
  changeHistory?: ChangeEntry[];
  wordCount?: number;
  backlinkCount?: number;
  metrics?: {
    wordCount: number;
    tableCount: number;
    diagramCount: number;
    internalLinks: number;
    externalLinks: number;
    footnoteCount: number;
    bulletRatio: number;
    sectionCount: number;
    hasOverview: boolean;
    structuralScore: number;
  };
  suggestedQuality?: number;
  unconvertedLinkCount?: number;
  redundancy?: {
    maxSimilarity: number;
    similarPages: Array<{
      id: string;
      title: string;
      path: string;
      similarity: number;
    }>;
  };
  /** Resolved canonical entity type (e.g. 'person', 'organization', 'risk') */
  entityType?: string;
  /** Computed hallucination risk — used by UI banners and AI agent triage */
  hallucinationRisk?: {
    /** Risk bucket: 'low' | 'medium' | 'high' */
    level: "low" | "medium" | "high";
    /** Numeric score 0-100 (higher = riskier) */
    score: number;
    /** Machine-readable factors explaining the score */
    factors: string[];
  };
}

// ============================================================================
// LOOKUP INDEXES (built lazily)
// ============================================================================

let _typedEntityIndex: Map<string, AnyEntity> | null = null;
let _resourceIndex: Map<string, Resource> | null = null;
let _publicationIndex: Map<string, Publication> | null = null;
let _expertIndex: Map<string, Expert> | null = null;
let _orgIndex: Map<string, Organization> | null = null;
let _pageIndex: Map<string, Page> | null = null;

function typedEntityIndex() {
  if (!_typedEntityIndex) {
    _typedEntityIndex = new Map(getTypedEntities().map(e => [e.id, e]));
  }
  return _typedEntityIndex;
}

function resourceIndex() {
  if (!_resourceIndex) {
    const db = getDatabase();
    _resourceIndex = new Map((db.resources || []).map((r) => [r.id, r]));
  }
  return _resourceIndex;
}

function publicationIndex() {
  if (!_publicationIndex) {
    const db = getDatabase();
    _publicationIndex = new Map(
      (db.publications || []).map((p) => [p.id, p])
    );
  }
  return _publicationIndex;
}

function expertIndex() {
  if (!_expertIndex) {
    const db = getDatabase();
    _expertIndex = new Map((db.experts || []).map((e) => [e.id, e]));
  }
  return _expertIndex;
}

function orgIndex() {
  if (!_orgIndex) {
    const db = getDatabase();
    _orgIndex = new Map((db.organizations || []).map((o) => [o.id, o]));
  }
  return _orgIndex;
}

function pageIndex() {
  if (!_pageIndex) {
    const db = getDatabase();
    _pageIndex = new Map((db.pages || []).map((p) => [p.id, p]));
  }
  return _pageIndex;
}

// ============================================================================
// LOOKUP FUNCTIONS
// ============================================================================

/** Get a typed entity by ID — accepts numeric (E35) or slug (deepmind) */
export function getTypedEntityById(id: string): AnyEntity | undefined {
  return typedEntityIndex().get(resolveId(id));
}

/** @deprecated Use getTypedEntityById for new code */
export function getEntityById(id: string): Entity | undefined {
  // Return typed entity cast to the old Entity interface for backward compat
  const typed = typedEntityIndex().get(resolveId(id));
  if (!typed) return undefined;
  return {
    id: typed.id,
    type: typed.entityType,
    title: typed.title,
    description: typed.description,
    tags: typed.tags,
    relatedEntries: typed.relatedEntries,
    sources: typed.sources,
    lastUpdated: typed.lastUpdated,
    website: typed.website,
    customFields: typed.customFields,
    // Type-specific fields (spread them for backward compat)
    ...(isRisk(typed) ? {
      severity: typed.severity,
      likelihood: typed.likelihood,
      timeframe: typed.timeframe,
      maturity: typed.maturity,
    } : {}),
  };
}

export function getResourceById(id: string): Resource | undefined {
  return resourceIndex().get(id);
}

export function getPublicationById(id: string): Publication | undefined {
  return publicationIndex().get(id);
}

export function getExpertById(id: string): Expert | undefined {
  return expertIndex().get(id);
}

export function getOrganizationById(id: string): Organization | undefined {
  return orgIndex().get(id);
}

export function getPageById(id: string): Page | undefined {
  return pageIndex().get(resolveId(id));
}

export function getAllPages(): Page[] {
  return getDatabase().pages || [];
}

export interface UpdateScheduleItem {
  id: string;
  numericId: string;
  title: string;
  quality: number | null;
  readerImportance: number | null;
  lastUpdated: string | null;
  updateFrequency: number;
  daysSinceUpdate: number;
  daysUntilDue: number;
  staleness: number;
  priority: number;
  category: string;
}

export function getUpdateSchedule(): UpdateScheduleItem[] {
  const db = getDatabase();
  const pages = db.pages || [];
  const now = Date.now();

  const items: UpdateScheduleItem[] = [];

  for (const page of pages) {
    if (!page.updateFrequency) continue;
    if (page.evergreen === false) continue;

    const lastUpdated = page.lastUpdated;
    const daysSince = lastUpdated
      ? Math.floor((now - new Date(lastUpdated).getTime()) / (1000 * 60 * 60 * 24))
      : 999;
    const daysUntil = page.updateFrequency - daysSince;
    const staleness = daysSince / page.updateFrequency;
    const readerImp = page.readerImportance ?? 50;
    const priority = staleness * (readerImp / 100);

    const numericId = db.idRegistry?.bySlug[page.id] || page.id;

    items.push({
      id: page.id,
      numericId,
      title: page.title,
      quality: page.quality,
      readerImportance: page.readerImportance,
      lastUpdated,
      updateFrequency: page.updateFrequency,
      daysSinceUpdate: daysSince,
      daysUntilDue: daysUntil,
      staleness: Math.round(staleness * 100) / 100,
      priority: Math.round(priority * 100) / 100,
      category: page.category,
    });
  }

  // Sort by priority descending (most urgent first)
  items.sort((a, b) => b.priority - a.priority);
  return items;
}

export interface PageRankingItem {
  id: string;
  numericId: string;
  title: string;
  quality: number | null;
  readerImportance: number | null;
  readerRank: number | null;
  researchImportance: number | null;
  researchRank: number | null;
  category: string;
  wordCount: number;
}

export function getPageRankings(): PageRankingItem[] {
  const db = getDatabase();
  const pages = db.pages || [];

  const items = pages
    .filter((p: Page) => p.readerImportance != null || p.researchImportance != null)
    .map((p: Page) => ({
      id: p.id,
      numericId: db.idRegistry?.bySlug[p.id] || p.id,
      title: p.title,
      quality: p.quality,
      readerImportance: p.readerImportance,
      readerRank: null as number | null,
      researchImportance: p.researchImportance,
      researchRank: null as number | null,
      category: p.category,
      wordCount: p.wordCount ?? p.metrics?.wordCount ?? 0,
    }));

  // Derive ranks from score ordering (scores are derived from rank, so this recovers position)
  const byReader = items.filter((i) => i.readerImportance != null).sort((a, b) => (b.readerImportance ?? 0) - (a.readerImportance ?? 0));
  byReader.forEach((item, idx) => { item.readerRank = idx + 1; });

  const byResearch = items.filter((i) => i.researchImportance != null).sort((a, b) => (b.researchImportance ?? 0) - (a.researchImportance ?? 0));
  byResearch.forEach((item, idx) => { item.researchRank = idx + 1; });

  // Default sort by readership importance
  items.sort((a, b) => (b.readerImportance ?? 0) - (a.readerImportance ?? 0));
  return items;
}

export interface PageChangeItem {
  pageId: string;
  pageTitle: string;
  pagePath: string;
  numericId: string;
  date: string;
  branch: string;
  sessionTitle: string;
  summary: string;
  category: string;
  pr?: number;
  model?: string;
  duration?: string;
  cost?: string;
}

export function getPageChanges(): PageChangeItem[] {
  const db = getDatabase();
  const pages = db.pages || [];
  const items: PageChangeItem[] = [];

  for (const page of pages) {
    if (!page.changeHistory || page.changeHistory.length === 0) continue;
    const numericId = db.idRegistry?.bySlug[page.id] || page.id;
    for (const entry of page.changeHistory) {
      items.push({
        pageId: page.id,
        pageTitle: page.title,
        pagePath: page.path,
        numericId,
        date: entry.date,
        branch: entry.branch,
        sessionTitle: entry.title,
        summary: entry.summary,
        category: page.category,
        ...(entry.pr !== undefined && { pr: entry.pr }),
        ...(entry.model !== undefined && { model: entry.model }),
        ...(entry.duration !== undefined && { duration: entry.duration }),
        ...(entry.cost !== undefined && { cost: entry.cost }),
      });
    }
  }

  // Sort by date descending (most recent first)
  items.sort((a, b) => b.date.localeCompare(a.date));
  return items;
}

export function getResourceCredibility(
  resource: Resource
): number | undefined {
  if (resource.credibility_override !== undefined) return resource.credibility_override;
  if (resource.publication_id) {
    const pub = getPublicationById(resource.publication_id);
    return pub?.credibility;
  }
  return undefined;
}

export function getResourcePublication(
  resource: Resource
): Publication | undefined {
  if (resource.publication_id) {
    return getPublicationById(resource.publication_id);
  }
  return undefined;
}

// ============================================================================
// PATH REGISTRY & ENTITY HREF
// ============================================================================

/**
 * Resolve an ID that may be numeric (E35) or a slug (deepmind) to its slug form.
 * Returns the original ID if it's already a slug or not found in the registry.
 */
export function resolveId(id: string): string {
  if (/^E\d+$/.test(id)) {
    const registry = getIdRegistry();
    return registry.byNumericId[id] || id;
  }
  return id;
}

export function getEntityPath(id: string): string | null {
  const slug = resolveId(id);
  const db = getDatabase();
  return db.pathRegistry?.[slug] || db.pathRegistry?.[`__index__/${slug}`] || null;
}

export function getIdRegistry(): IdRegistryMaps {
  return getDatabase().idRegistry;
}

export function getEntityHref(id: string, _type?: string): string {
  const registry = getIdRegistry();
  // If already a numeric ID (E35), use it directly
  if (/^E\d+$/.test(id) && registry.byNumericId[id]) {
    return `/wiki/${id}`;
  }
  // Otherwise look up slug → numeric ID
  const numericId = registry.bySlug[id];
  return numericId ? `/wiki/${numericId}` : `/wiki/${id}`;
}

// ============================================================================
// BACKLINKS
// ============================================================================

export function getBacklinksFor(
  entityId: string
): Array<{
  id: string;
  type: string;
  title: string;
  href: string;
  relationship?: string;
}> {
  const slug = resolveId(entityId);
  const db = getDatabase();
  const links = db.backlinks?.[slug] || [];
  return links.map((link) => ({
    ...link,
    href: getEntityHref(link.id, link.type),
  }));
}

// ============================================================================
// RELATED GRAPH (bidirectional, multi-signal)
// ============================================================================

export function getRelatedGraphFor(
  entityId: string
): Array<{
  id: string;
  type: string;
  title: string;
  href: string;
  score: number;
  label?: string;
}> {
  const db = getDatabase();
  const entries = db.relatedGraph?.[entityId] || [];
  return entries.map((entry) => ({
    ...entry,
    href: getEntityHref(entry.id, entry.type),
  }));
}

// ============================================================================
// CANONICAL FACTS
// ============================================================================

export function getFact(entityId: string, factId: string): Fact | undefined {
  const db = getDatabase();
  return db.facts?.[`${entityId}.${factId}`];
}

export function getFactValue(entityId: string, factId: string): string | undefined {
  return getFact(entityId, factId)?.value;
}

export function getFactsForEntity(entityId: string): Record<string, Fact> {
  const db = getDatabase();
  const result: Record<string, Fact> = {};
  for (const [key, fact] of Object.entries(db.facts || {})) {
    if (fact.entity === entityId) {
      result[fact.factId] = fact;
    }
  }
  return result;
}

export function getAllFacts(): Array<Fact & { key: string }> {
  const db = getDatabase();
  return Object.entries(db.facts || {}).map(([key, fact]) => ({
    ...fact,
    key,
  }));
}

// ============================================================================
// FACT MEASURES & TIMESERIES
// ============================================================================

/** Get all measure definitions */
export function getFactMeasures(): Record<string, FactMeasure> {
  return getDatabase().factMeasures || {};
}

/** Get a single measure definition by ID */
export function getFactMeasure(measureId: string): FactMeasure | undefined {
  return getDatabase().factMeasures?.[measureId];
}

/**
 * Get timeseries for a measure, optionally filtered by entity.
 * Returns observations sorted chronologically (oldest first).
 */
export function getMeasureTimeseries(measureId: string, entityId?: string): TimeseriesPoint[] {
  const db = getDatabase();
  const series = db.factTimeseries?.[measureId] || [];
  if (entityId) {
    return series.filter(p => p.entity === entityId);
  }
  return series;
}

/**
 * Get all timeseries data for a given entity, grouped by measure.
 * Returns a map of measureId → sorted observations.
 */
export function getEntityTimeseries(entityId: string): Record<string, TimeseriesPoint[]> {
  const db = getDatabase();
  const result: Record<string, TimeseriesPoint[]> = {};
  for (const [measureId, series] of Object.entries(db.factTimeseries || {})) {
    const filtered = series.filter(p => p.entity === entityId);
    if (filtered.length > 0) {
      result[measureId] = filtered;
    }
  }
  return result;
}

/** Get all measures that have data for a given entity */
export function getEntityMeasures(entityId: string): FactMeasure[] {
  const db = getDatabase();
  const measures: FactMeasure[] = [];
  const seen = new Set<string>();
  for (const [measureId, series] of Object.entries(db.factTimeseries || {})) {
    if (seen.has(measureId)) continue;
    if (series.some(p => p.entity === entityId)) {
      const measure = db.factMeasures?.[measureId];
      if (measure) {
        measures.push(measure);
        seen.add(measureId);
      }
    }
  }
  return measures;
}

// ============================================================================
// INTERVENTIONS
// ============================================================================

export function getInterventions(): Intervention[] {
  const db = getDatabase();
  return db.interventions || [];
}

// ============================================================================
// PROPOSALS
// ============================================================================

export interface Proposal {
  id: string;
  name: string;
  description?: string;
  sourcePageId?: string;
  domain?: string;
  stance?: string;
  costEstimate?: string;
  evEstimate?: string;
  feasibility?: string;
  honestConcerns?: string;
  status?: string;
  leadOrganizations?: string[];
  relatedProposals?: string[];
}

export function getProposals(): Proposal[] {
  const db = getDatabase();
  return db.proposals || [];
}

// ============================================================================
// PR ITEMS (GitHub pull request metadata)
// ============================================================================

export interface PrItem {
  number: number;
  title: string;
  body: string;
  state: string;
  branch: string;
  author: string;
  createdAt: string;
  updatedAt: string;
  mergedAt: string | null;
  closedAt: string | null;
  labels: string[];
}

export function getPrItems(): PrItem[] {
  const db = getDatabase();
  return db.prItems || [];
}

// ============================================================================
// INSIGHTS
// ============================================================================

/** Build path→title lookup from pages, normalising trailing slashes. */
function getPageTitleMap(): Map<string, string> {
  const db = getDatabase();
  const map = new Map<string, string>();
  for (const page of db.pages || []) {
    map.set(page.path, page.title);
    if (!page.path.endsWith("/")) {
      map.set(page.path + "/", page.title);
    }
  }
  return map;
}

// ============================================================================
// INFOBOX DATA HELPERS
// ============================================================================

export function getEntityInfoBoxData(entityId: string) {
  const entity = getTypedEntityById(entityId);
  if (!entity) return null;

  const resolvedRelatedEntries = entity.relatedEntries?.map((entry) => ({
    id: entry.id,
    type: entry.type,
    title:
      getTypedEntityById(entry.id)?.title ||
      entry.id
        .split("-")
        .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
        .join(" "),
    href: getEntityHref(entry.id, entry.type),
  }));

  // Resolve likelihood/timeframe to strings
  let likelihoodStr: string | undefined;
  let timeframeStr: string | undefined;
  let category: string | undefined;
  let maturity: string | undefined;
  let relatedSolutions: Array<{ id: string; title: string; type: string; href: string }> | undefined;
  let severity: string | undefined;

  if (isRisk(entity)) {
    severity = entity.severity;
    category = entity.riskCategory;
    maturity = entity.maturity;
    if (entity.likelihood) {
      likelihoodStr =
        typeof entity.likelihood === "string"
          ? entity.likelihood
          : entity.likelihood?.display || entity.likelihood?.level;
    }
    if (entity.timeframe) {
      timeframeStr =
        typeof entity.timeframe === "string"
          ? entity.timeframe
          : entity.timeframe?.display || String(entity.timeframe?.median || "");
    }
    // Find related solutions
    const allEntities = getTypedEntities();
    relatedSolutions = [];
    for (const solution of allEntities) {
      if (
        solution.entityType === "safety-agenda" ||
        solution.entityType === "approach" ||
        solution.entityType === "project"
      ) {
        const linkedRisks =
          solution.relatedEntries?.filter((re) => re.type === "risk") || [];
        if (linkedRisks.some((r) => r.id === entity.id)) {
          relatedSolutions.push({
            id: solution.id,
            title: solution.title,
            type: solution.entityType,
            href: getEntityHref(solution.id, solution.entityType),
          });
        }
      }
    }
  }

  // Person-specific fields
  let affiliation: string | undefined;
  let role: string | undefined;
  let knownFor: string | undefined;

  if (isPerson(entity)) {
    affiliation = entity.affiliation;
    role = entity.role;
    knownFor = entity.knownFor?.join(", ");
  }

  // Organization-specific fields
  let founded: string | undefined;
  let location: string | undefined;
  let headcount: string | undefined;
  let funding: string | undefined;
  let orgType: string | undefined;

  if (isOrganization(entity)) {
    founded = entity.founded;
    location = entity.headquarters;
    headcount = entity.employees;
    funding = entity.funding;
    orgType = entity.orgType;
  }

  // Policy-specific fields
  let introduced: string | undefined;
  let policyStatus: string | undefined;
  let policyAuthor: string | undefined;
  let scope: string | undefined;

  if (isPolicy(entity)) {
    introduced = entity.introduced;
    policyStatus = entity.policyStatus;
    policyAuthor = entity.author;
    scope = entity.scope;
  }

  // Resolve summaryPage to title + href
  let summaryPage: { title: string; href: string } | undefined;
  if (entity.summaryPage) {
    const summaryEntity = getTypedEntityById(entity.summaryPage);
    const summaryPageData = getPageById(entity.summaryPage);
    const summaryTitle =
      summaryEntity?.title ||
      summaryPageData?.title ||
      entity.summaryPage
        .split("-")
        .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
        .join(" ");
    summaryPage = {
      title: summaryTitle,
      href: getEntityHref(entity.summaryPage),
    };
  }

  return {
    type: entity.entityType,
    title: entity.title,
    severity,
    likelihood: likelihoodStr,
    timeframe: timeframeStr,
    website: entity.website,
    customFields: entity.customFields,
    relatedTopics: entity.relatedTopics,
    relatedEntries: resolvedRelatedEntries,
    category,
    maturity,
    relatedSolutions,
    summaryPage,
    // Person
    affiliation,
    role,
    knownFor,
    // Organization
    founded,
    location,
    headcount,
    funding,
    orgType,
    // Policy
    introduced,
    policyStatus,
    policyAuthor,
    scope,
    // Overview
    childPages: entity.entityType === "overview"
      ? getChildPagesForOverview(entity.id)
      : undefined,
  };
}

// ============================================================================
// CHILD PAGES (for overview entities)
// ============================================================================

export interface ChildPageEntry {
  id: string;
  title: string;
  type: string;
  href: string;
}

/**
 * Find all entities that reference this overview page via `summaryPage`.
 * Returns them grouped by entity type for display in the InfoBox.
 */
export function getChildPagesForOverview(overviewId: string): ChildPageEntry[] {
  const allEntities = getTypedEntities();
  const children: ChildPageEntry[] = [];

  for (const entity of allEntities) {
    if (entity.summaryPage === overviewId) {
      children.push({
        id: entity.id,
        title: entity.title,
        type: entity.entityType,
        href: getEntityHref(entity.id, entity.entityType),
      });
    }
  }

  // Sort alphabetically by title
  children.sort((a, b) => a.title.localeCompare(b.title));
  return children;
}

// ============================================================================
// EXTERNAL LINKS (loads YAML via fs)
// ============================================================================

export interface ExternalLinksData {
  wikipedia?: string;
  wikidata?: string;
  lesswrong?: string;
  alignmentForum?: string;
  eaForum?: string;
  stampy?: string;
  arbital?: string;
  eightyK?: string;
  grokipedia?: string;
}

let _externalLinksMap: Map<string, ExternalLinksData> | null = null;

function loadExternalLinksMap(): Map<string, ExternalLinksData> {
  if (_externalLinksMap) return _externalLinksMap;

  try {
    const yamlPath = path.join(DATA_DIR, "external-links.yaml");
    const raw = fs.readFileSync(yamlPath, "utf-8");
    const entries = yaml.load(raw) as Array<{
      pageId: string;
      links: ExternalLinksData;
    }>;
    _externalLinksMap = new Map();
    for (const entry of entries) {
      if (entry.pageId && entry.links) {
        _externalLinksMap.set(entry.pageId, entry.links);
      }
    }
    return _externalLinksMap;
  } catch {
    return new Map();
  }
}

export function getExternalLinks(
  pageId: string
): ExternalLinksData | undefined {
  return loadExternalLinksMap().get(resolveId(pageId));
}

// ============================================================================
// EXPLORE PAGE DATA
// ============================================================================

export interface ExploreItem {
  id: string;
  numericId: string;
  title: string;
  type: string;
  description: string | null;
  tags: string[];
  clusters: string[];
  wordCount: number | null;
  quality: number | null;
  readerImportance: number | null;
  researchImportance: number | null;
  backlinkCount: number | null;
  category: string | null;
  riskCategory: string | null;
  lastUpdated: string | null;
  contentFormat?: ContentFormat;
  href?: string;
  meta?: string;
  sourceTitle?: string;
}

// Map page categories to entity-like types for display
const CATEGORY_TO_TYPE: Record<string, string> = {
  responses: "approach",
  organizations: "organization",
  people: "person",
  factors: "model",
  "intelligence-paradigms": "capability",
  models: "model",
  scenarios: "model",
  reports: "analysis",
  cruxes: "crux",
  worldviews: "concept",
  risks: "risk",
  forecasting: "model",
  "foundation-models": "capability",
  incidents: "historical",
  other: "concept",
};

// Table items are now derived from pages with contentFormat=table.
// The hardcoded TABLES array has been eliminated — all table pages are
// detected automatically via the contentFormat field in frontmatter.

export function getExploreItems(): ExploreItem[] {
  const db = getDatabase();
  const typedEntities = getTypedEntities();
  const pageMap = new Map((db.pages || []).map((p) => [p.id, p]));
  const entityIds = new Set(typedEntities.map((e) => e.id));

  // Items from typed entities (only those with actual content pages)
  const entityItems: ExploreItem[] = typedEntities.filter((entity) => pageMap.has(entity.id)).map((entity) => {
    const page = pageMap.get(entity.id)!;
    return {
      id: entity.id,
      numericId: entity.numericId || db.idRegistry?.bySlug[entity.id] || entity.id,
      title: entity.title,
      type: page?.contentFormat === "table" ? "table" : page?.contentFormat === "diagram" ? "diagram" : entity.entityType,
      description: page?.llmSummary || page?.description || entity.description || null,
      tags: entity.tags || [],
      clusters: entity.clusters?.length ? entity.clusters : (page?.clusters || []),
      wordCount: page?.wordCount ?? null,
      quality: page?.quality ?? null,
      readerImportance: page?.readerImportance ?? null,
      researchImportance: page?.researchImportance ?? null,
      backlinkCount: page?.backlinkCount ?? null,
      category: page?.category ?? null,
      riskCategory: isRisk(entity) ? (entity.riskCategory || null) : null,
      lastUpdated: page?.lastUpdated ?? null,
      contentFormat: page?.contentFormat,
    };
  });

  // Items from pages that have no entity
  const pageOnlyItems: ExploreItem[] = (db.pages || [])
    .filter((p) => !entityIds.has(p.id))
    .filter((p) => p.title && p.category !== "schema")
    .map((page) => ({
      id: page.id,
      numericId: db.idRegistry?.bySlug[page.id] || page.id,
      title: page.title,
      type: page.contentFormat === "table" ? "table" : page.contentFormat === "diagram" ? "diagram" : CATEGORY_TO_TYPE[page.category] || "concept",
      description: page.llmSummary || page.description || null,
      tags: page.tags || [],
      clusters: page.clusters || [],
      wordCount: page.wordCount ?? null,
      quality: page.quality ?? null,
      readerImportance: page.readerImportance ?? null,
      researchImportance: page.researchImportance ?? null,
      backlinkCount: page.backlinkCount ?? null,
      category: page.category ?? null,
      riskCategory: null,
      lastUpdated: page.lastUpdated ?? null,
      contentFormat: page.contentFormat,
    }));

  // Diagram items — entities with causeEffectGraph data
  // Generic entities preserve all raw fields including causeEffectGraph.
  // Entity IDs may differ from page IDs (e.g. entity "tmc-compute" → page "compute",
  // entity "misalignment-potential" → page "factors-misalignment-potential-overview"),
  // so we resolve the correct page for each diagram entity.
  function resolveDiagramHref(e: AnyEntity): string | null {
    const raw = e as unknown as RawEntity;
    // 1. Direct match: entity ID is the page ID
    if (pageMap.has(e.id)) return getEntityHref(e.id);
    // 2. Entity has explicit path field → derive page ID from path
    if (raw.path) {
      const segments = raw.path.replace(/\/$/, "").split("/");
      const pageId = segments[segments.length - 1];
      if (pageId && pageMap.has(pageId)) {
        const numId = db.idRegistry?.bySlug[pageId];
        return numId ? `/wiki/${numId}` : `/wiki/${pageId}`;
      }
    }
    // 3. Factor entities: try "factors-{id}-overview" pattern
    const overviewId = `factors-${e.id}-overview`;
    if (pageMap.has(overviewId)) {
      const numId = db.idRegistry?.bySlug[overviewId];
      return numId ? `/wiki/${numId}` : `/wiki/${overviewId}`;
    }
    return null;
  }

  const diagramItems: ExploreItem[] = typedEntities
    .filter((e) => {
      const ceg = (e as unknown as RawEntity).causeEffectGraph;
      if (!ceg?.nodes?.length) return false;
      // Only include diagrams that resolve to a valid page
      return resolveDiagramHref(e) !== null;
    })
    .map((e) => {
      const ceg = (e as unknown as RawEntity).causeEffectGraph!;
      const nodeCount = ceg.nodes?.length || 0;
      return {
        id: `diagram-${e.id}`,
        numericId: `diagram-${e.id}`,
        title: ceg.title || e.title,
        type: "diagram",
        description: ceg.description || `Cause-effect diagram for ${e.title}`,
        tags: [] as string[],
        clusters: ["ai-safety"],
        wordCount: null,
        quality: null,
        readerImportance: null,
        researchImportance: null,
        backlinkCount: null,
        category: null,
        riskCategory: null,
        lastUpdated: e.lastUpdated || null,
        contentFormat: "diagram" as ContentFormat,
        href: resolveDiagramHref(e)!,
        meta: `${nodeCount} nodes`,
      };
    });

  return [...entityItems, ...pageOnlyItems, ...diagramItems];
}
